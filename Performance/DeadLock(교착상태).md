# DaedLock(교착상태)

- **한정된 자원을 여러 곳에서 사용**하려고 할 때 발생한다.

- 어떤 프로세스가 자원을 요청 했을 때 그 시각에 그 자원을 사용할 수 없는 상황이 발생할 수 있고 그 때는 프로세스가 **대기 상태**로 들어 간다.

- **대기 상태로 들어간 프로세스가 실행 될 수 없는 상황**을 교착 상태라 한다.

<br/>

## DaedLock의 발생 조건

DeadLock은 한 시스템 내에서 4가지 조건이 동시에 성립 할 때 발생한다. 즉, 4가지 조건 중 **하나라도 성립하지 않으면 DeadLock은 발생하지 않는다.**

- **상호배제((Mutual exclusion)** : 하나의 프로세스가 자원을 사용할 경우 다른 프로세스는 그 자원을 사용할 수 없는 것

- **점유대기(Hold and wait)** :  프로세스가 자신이 가질 수 있는 자원은 가지고 있으면서 다른 자원이 오기를 기다리고 있는 것

- **비선점(No Preemption)** : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없는 것

- **순환대기(Circular wait)** : 첫 번째 프로세스와 마지막 프로세스의 자원할당이 겹치게 되어 원형에 있는 모든 프로세스가 자원 할당을 받고자 기다리는 형태가 만들어지는 것

<br/>

## DeadLock의 예방과 회피

### DeadLock의 예방

---

- **상호배제 예방** : 상호배제 사용하지 않음(**동시액세스 허락**)

- **점유대기 예방**: 프로세스가 필요로 하는 자원을 **일시에 요구/할당**

- **비선점 예방** : **자원 임시 할당 해제 및 원상 복구**

- **순환대기 예방** : 모든 자원의 **고유번호 지정**한다.

위의 4가지 조건 중 하나라도 발생하지 않도록 시스템 차원에서 막아버리면 해결된다.

근데 이 방법은 대부분 자원이 낭비되는 경향이 있다. 그리고 애초에 발생 가능성을 시스템 차원에서 막아버리면 성능이 나빠지거나 또 다른 문제의 원인이 될 수 있다.

### DeadLock의 회피

---

교착상태의 발생 조건은 놔두고, **발생을 막는 알고리즘을 적용**해서 해결하는 방법이다.

대표적으로 **은행원 알고리즘**이 있다.

**은행원 알고리즘(Banker's Algorithm)**은 프로세스가 자원을 요구할 때 시스템이 자원을 할당한 후 안정 상태로 남아있는지를 사전에 검사한 후 **안정 상태라면 자원을 할당**하는 방식이다.

만약, 안정 상태가 아니라면 **다른 프로세스들이 점유한 자원을 해제할 때까지 대기**한다.

1. 자원 상황와 자원 종류의 최대 수를 파악.

2. 프로세스가 자원 할당 요구.

3. 시스템 상태를 파악 후 자원 할당 여부를 결정.

4. 안정 상태라면 할당 아니라면 대기.

<br/>

#### 은행원 알고리즘의 자료 구조

- Available[n] : 자원 n의 사용 가능 개수.

- Max[m,n] : 프로세스 m 의 자원 n의 최대 요구 개수 

- Allocation[m,n] : 프로세스 m 에 할당된 자원 n의 개수

- Need[m,n] : 프로세스 m이 추가적으로 필요로 하는 자원 n의 개수

<br/>

---

#### Reference

- [운영체제 - 교착상태, 기아상태, 은행가 알고리즘](https://m.blog.naver.com/PostView.nhn?blogId=dong5053&logNo=220717510273&proxyReferer=https%3A%2F%2Fwww.google.com%2F)
- [DeadLock 발생 조건 4가지 및 해결 방법](https://blog.lael.be/post/1304)
